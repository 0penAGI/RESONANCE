<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RIFT: Colony Builder</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: #1e293b;
            --accent-primary: #06b6d4;
            --accent-secondary: #d946ef;
            --success: #22c55e;
            --danger: #ef4444;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --grid-line: #334155;
            --cell-size: clamp(30px, 9vmin, 60px);
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #threeContainer {
            position: fixed;
            inset: 0;
            z-index: 1;
        }

        header {
            background: var(--panel-bg);
            padding: 10px 15px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            z-index: 10;
            border-bottom: 1px solid var(--grid-line);
            position: relative;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        h1 {
            margin: 0;
            font-size: 1.2rem;
            font-weight: 800;
            letter-spacing: 1px;
            background: linear-gradient(to right, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.2);
            padding: 4px;
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }

        main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            position: relative;
            z-index: 5;
            pointer-events: none;
        }

        .city-grid {
            display: none;
        }

        .controls {
            background: var(--panel-bg);
            border-top: 1px solid var(--grid-line);
            padding: 10px;
            z-index: 20;
            position: relative;
        }

        .tools-scroll {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding-bottom: 5px;
            scrollbar-width: none;
        }
        .tools-scroll::-webkit-scrollbar { display: none; }

        .tool-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--grid-line);
            border-radius: 8px;
            padding: 8px 12px;
            min-width: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-muted);
            pointer-events: auto;
        }

        .tool-btn.selected {
            background: rgba(6, 182, 212, 0.2);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .tool-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-name { font-size: 0.7rem; font-weight: bold; }
        .tool-cost { font-size: 0.65rem; color: var(--text-muted); }
        .tool-btn.selected .tool-cost { color: var(--accent-primary); }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.open {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--accent-primary);
            padding: 25px;
            border-radius: 12px;
            max-width: 90%;
            width: 400px;
            text-align: center;
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
        }

        .modal h2 { margin-top: 0; color: var(--accent-primary); }
        .modal p { color: var(--text-muted); line-height: 1.5; }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            padding: 12px 24px;
            color: white;
            font-weight: bold;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 15px;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 1rem;
        }

        .btn-primary:active { transform: scale(0.98); }

        .toast-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 50;
            pointer-events: none;
        }

        .toast {
            background: rgba(0,0,0,0.8);
            border-left: 4px solid var(--accent-primary);
            color: white;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.9rem;
            animation: slideUp 0.3s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .floater {
            position: absolute;
            color: var(--success);
            font-weight: bold;
            font-size: 0.8rem;
            pointer-events: none;
            animation: floatUp 1s forwards;
            z-index: 10;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }

    </style>
</head>
<body>

    <div id="threeContainer"></div>

    <div id="startModal" class="modal-overlay open">
        <div class="modal">
            <h2>Welcome to RIFT</h2>
            <p>Establish a colony within the dimensional void.</p>
            <p>Build <strong>Hab-Domes</strong> for population. Build <strong>Reactors</strong> for power. Build <strong>Trade Hubs</strong> to earn credits.</p>
            <p style="font-size: 0.9rem; color: var(--accent-secondary)">‚ö†Ô∏è Warning: Running out of Credits or Energy leads to collapse.</p>
            <button class="btn-primary" onclick="startGame()">Initialize System</button>
        </div>
    </div>

    <div id="gameOverModal" class="modal-overlay">
        <div class="modal">
            <h2 id="goTitle" style="color: var(--danger)">System Failure</h2>
            <p id="goMessage">The colony has collapsed.</p>
            <div style="margin: 15px 0; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 6px;">
                <div>Final Population: <span id="goPop" style="color:white; font-weight:bold">0</span></div>
                <div>Cycles Survived: <span id="goCycle" style="color:white; font-weight:bold">0</span></div>
            </div>
            <button class="btn-primary" onclick="resetGame()">Reboot System</button>
        </div>
    </div>

    <header>
        <div class="header-top">
            <h1>RIFT</h1>
            <div style="font-size: 0.7rem; color: var(--accent-primary)">Cycle: <span id="cycleDisplay">0</span></div>
        </div>
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-label">Credits</span>
                <span class="stat-value" id="moneyDisplay" style="color: #fbbf24">100</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Energy</span>
                <span class="stat-value" id="energyDisplay" style="color: #f87171">20</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Population</span>
                <span class="stat-value" id="popDisplay" style="color: #60a5fa">0</span>
            </div>
        </div>
    </header>

    <main>
        <div id="grid" class="city-grid"></div>
    </main>

    <div class="controls">
        <div class="tools-scroll">
            <div class="tool-btn" onclick="selectTool('bulldoze')">
                <div class="tool-icon">üöß</div>
                <div class="tool-name">Clear</div>
                <div class="tool-cost">+5 Credits</div>
            </div>
            <div class="tool-btn selected" onclick="selectTool('residential')" id="btn-residential">
                <div class="tool-icon">üè†</div>
                <div class="tool-name">Hab-Dome</div>
                <div class="tool-cost">50 Credits</div>
            </div>
            <div class="tool-btn" onclick="selectTool('industrial')" id="btn-industrial">
                <div class="tool-icon">‚ö°</div>
                <div class="tool-name">Reactor</div>
                <div class="tool-cost">100 Credits</div>
            </div>
            <div class="tool-btn" onclick="selectTool('commercial')" id="btn-commercial">
                <div class="tool-icon">üè¢</div>
                <div class="tool-name">Trade Hub</div>
                <div class="tool-cost">150 Credits</div>
            </div>
            <div class="tool-btn" onclick="selectTool('park')" id="btn-park">
                <div class="tool-icon">üå≥</div>
                <div class="tool-name">Bio-Dome</div>
                <div class="tool-cost">75 Credits</div>
            </div>
        </div>
    </div>

    <div id="toastContainer" class="toast-container"></div>

    <script>
        const GRID_SIZE = 8;
        const TICK_RATE = 3000;

        const BUILDINGS = {
            'residential': { 
                name: 'Hab-Dome', icon: 'üè†', cost: 50, 
                energy: -2, pop: 5, income: 0, color: 0x60a5fa, height: 1.5
            },
            'industrial': { 
                name: 'Reactor', icon: '‚ö°', cost: 100, 
                energy: 15, pop: 0, income: 0, color: 0xf87171, height: 2
            },
            'commercial': { 
                name: 'Trade Hub', icon: 'üè¢', cost: 150, 
                energy: -5, pop: 0, income: 15, color: 0xfbbf24, height: 2.5
            },
            'park': { 
                name: 'Bio-Dome', icon: 'üå≥', cost: 75, 
                energy: -1, pop: 0, income: 0, color: 0x4ade80, height: 1
            },
            'bulldoze': {
                name: 'Clear', icon: '', cost: -5,
                energy: 0, pop: 0, income: 0, color: 0x000000, height: 0
            }
        };

        let state = {
            credits: 100,
            energy: 20,
            population: 0,
            cycle: 0,
            grid: [],
            selectedTool: 'residential',
            gameActive: false,
            timer: null
        };

        let scene, camera, renderer, raycaster, mouse;
        let groundPlane, highlightMesh;
        let buildingMeshes = {};
        const CELL_SIZE = 1;
        const GRID_OFFSET = GRID_SIZE / 2;

        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x05080f);

            camera = new THREE.OrthographicCamera(-8, 8, 8, -8, 0.1, 100);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById("threeContainer").appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dir = new THREE.DirectionalLight(0x00ffff, 0.8);
            dir.position.set(10, 20, 10);
            scene.add(dir);

            const planeGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE);
            const planeMat = new THREE.MeshBasicMaterial({ visible: false });
            groundPlane = new THREE.Mesh(planeGeo, planeMat);
            groundPlane.rotation.x = -Math.PI / 2;
            scene.add(groundPlane);

            const grid = new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x00ffff, 0x223344);
            scene.add(grid);

            const hGeo = new THREE.PlaneGeometry(1, 1);
            const hMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.3
            });
            highlightMesh = new THREE.Mesh(hGeo, hMat);
            highlightMesh.rotation.x = -Math.PI / 2;
            highlightMesh.visible = false;
            scene.add(highlightMesh);

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointermove', onPointerMove);
            renderer.domElement.addEventListener('click', onPointerClick);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (buildingMeshes) {
                Object.values(buildingMeshes).forEach(mesh => {
                    if (mesh && mesh.rotation) {
                        mesh.rotation.y += 0.005;
                    }
                });
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.left = -window.innerWidth / 150;
            camera.right = window.innerWidth / 150;
            camera.top = window.innerHeight / 150;
            camera.bottom = -window.innerHeight / 150;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onPointerMove(event) {
            if (!renderer) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hit = raycaster.intersectObject(groundPlane);

            if (hit.length) {
                const p = hit[0].point;
                const gx = Math.floor(p.x + GRID_OFFSET);
                const gy = Math.floor(p.z + GRID_OFFSET);

                if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                    highlightMesh.position.set(
                        gx - GRID_OFFSET + 0.5,
                        0.01,
                        gy - GRID_OFFSET + 0.5
                    );
                    highlightMesh.visible = true;
                } else {
                    highlightMesh.visible = false;
                }
            }
        }

        function onPointerClick(event) {
            if (!state.gameActive) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hit = raycaster.intersectObject(groundPlane);

            if (hit.length) {
                const p = hit[0].point;
                const gx = Math.floor(p.x + GRID_OFFSET);
                const gy = Math.floor(p.z + GRID_OFFSET);

                if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                    handleCellClick(gx, gy);
                }
            }
        }

        function createBuilding(x, y, type) {
            const buildingData = BUILDINGS[type];
            const geometry = new THREE.BoxGeometry(0.8, buildingData.height, 0.8);
            const material = new THREE.MeshStandardMaterial({ 
                color: buildingData.color,
                emissive: buildingData.color,
                emissiveIntensity: 0.3,
                metalness: 0.5,
                roughness: 0.5
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(
                x - GRID_OFFSET + 0.5,
                buildingData.height / 2,
                y - GRID_OFFSET + 0.5
            );
            
            scene.add(mesh);
            return mesh;
        }

        function removeBuilding(x, y) {
            const key = `${x}-${y}`;
            if (buildingMeshes[key]) {
                scene.remove(buildingMeshes[key]);
                buildingMeshes[key].geometry.dispose();
                buildingMeshes[key].material.dispose();
                delete buildingMeshes[key];
            }
        }

        function initGrid() {
            state.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    row.push(null);
                }
                state.grid.push(row);
            }
        }

        function startGame() {
            document.getElementById('startModal').classList.remove('open');
            resetState();
            initGrid();
            updateUI();
            state.gameActive = true;
            
            if (state.timer) clearInterval(state.timer);
            state.timer = setInterval(gameTick, TICK_RATE);
            
            showToast("System Online. Awaiting construction.");
        }

        function resetState() {
            Object.values(buildingMeshes).forEach(mesh => {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
            });
            buildingMeshes = {};

            state = {
                credits: 150,
                energy: 20,
                population: 0,
                cycle: 0,
                grid: [],
                selectedTool: 'residential',
                gameActive: false,
                timer: null
            };
        }

        function resetGame() {
            document.getElementById('gameOverModal').classList.remove('open');
            startGame();
        }

        function selectTool(toolName) {
            state.selectedTool = toolName;
            
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('selected'));
            const buttons = document.querySelectorAll('.tool-btn');
            if(toolName === 'bulldoze') buttons[0].classList.add('selected');
            else {
                const map = { 'residential': 1, 'industrial': 2, 'commercial': 3, 'park': 4 };
                if(buttons[map[toolName]]) buttons[map[toolName]].classList.add('selected');
            }
        }

        function handleCellClick(x, y) {
            if (!state.gameActive) return;

            const currentBuilding = state.grid[y][x];
            const tool = state.selectedTool;

            if (tool === 'bulldoze') {
                if (currentBuilding) {
                    const buildingData = BUILDINGS[currentBuilding];
                    const refund = Math.floor(buildingData.cost * 0.5) - 5; 
                    
                    state.credits += refund;
                    state.grid[y][x] = null;
                    removeBuilding(x, y);
                    
                    updateUI();
                    showToast(`Cleared. Refund: ${refund} Credits`);
                }
                return;
            }

            if (currentBuilding) {
                showToast("Space occupied! Clear it first.", "error");
                return;
            }

            const buildingConfig = BUILDINGS[tool];

            if (state.credits >= buildingConfig.cost) {
                state.credits -= buildingConfig.cost;
                state.grid[y][x] = tool;
                
                const key = `${x}-${y}`;
                buildingMeshes[key] = createBuilding(x, y, tool);

                calculateStats(); 
                updateUI();
                showToast(`Built ${buildingConfig.name}`);
            } else {
                showToast("Insufficient Credits!", "error");
                shakeUI();
            }
        }

        function calculateStats() {
            let pop = 0;
            let energyProd = 0;
            let energyUse = 0;
            let income = 0;

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const type = state.grid[y][x];
                    if (type) {
                        const b = BUILDINGS[type];
                        pop += b.pop;
                        if (b.energy > 0) energyProd += b.energy;
                        else energyUse += Math.abs(b.energy);
                        income += b.income;
                    }
                }
            }

            const totalEnergy = energyProd - energyUse;
            const efficiency = Math.min(1, pop / 50); 
            const finalIncome = Math.floor(income * efficiency);

            return { pop, totalEnergy, finalIncome };
        }

        function gameTick() {
            if (!state.gameActive) return;

            const stats = calculateStats();
            state.population = stats.pop;
            state.cycle++;

            const maintenance = state.population * 1;
            const netIncome = stats.finalIncome - maintenance;
            state.credits += netIncome;
            state.energy = stats.totalEnergy;

            if (state.credits < 0) {
                gameOver("Bankruptcy. The colony ran out of funding.");
                return;
            }

            if (state.energy < 0) {
                showToast("‚ö†Ô∏è BLACKOUT: Energy Deficit!", "error");
                state.credits = Math.max(0, state.credits - 20);
            }

            if (netIncome > 0) {
                showToast(`Cycle ${state.cycle}: +${netIncome} Credits`);
            } else if (netIncome < 0) {
                showToast(`Cycle ${state.cycle}: ${netIncome} Credits`, "error");
            }

            updateUI();
        }

        function gameOver(reason) {
            state.gameActive = false;
            clearInterval(state.timer);
            document.getElementById('goTitle').innerText = "COLLAPSE";
            document.getElementById('goMessage').innerText = reason;
            document.getElementById('goPop').innerText = state.population;
            document.getElementById('goCycle').innerText = state.cycle;
            document.getElementById('gameOverModal').classList.add('open');
        }

        function updateUI() {
            const stats = calculateStats();
            
            document.getElementById('moneyDisplay').innerText = Math.floor(state.credits);
            document.getElementById('popDisplay').innerText = stats.pop;
            document.getElementById('cycleDisplay').innerText = state.cycle;
            
            const energyEl = document.getElementById('energyDisplay');
            energyEl.innerText = stats.totalEnergy;
            energyEl.style.color = stats.totalEnergy < 0 ? 'var(--danger)' : '#f87171';
        }

        function showToast(msg, type = 'normal') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.innerText = msg;
            if (type === 'error') toast.style.borderLeftColor = 'var(--danger)';
            
            container.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-10px)';
                setTimeout(() => toast.remove(), 300);
            }, 2000);
        }

        function shakeUI() {
            const header = document.querySelector('header');
            header.style.transform = "translateX(5px)";
            setTimeout(() => header.style.transform = "translateX(-5px)", 50);
            setTimeout(() => header.style.transform = "translateX(5px)", 100);
            setTimeout(() => header.style.transform = "translateX(0)", 150);
        }

        document.addEventListener('DOMContentLoaded', () => {
            initGrid();
            initThree();
        });

    </script>
</body>
</html>
