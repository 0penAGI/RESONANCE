<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Резонанс: Лабиринт Хаоса</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
            height: 100vh;
            position: relative;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        #interface {
            position: absolute;
            top: 98px;
            left: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 10;
        }
        .stat {
            margin: 2px 0;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
        #memory-trace {
            position: absolute;
            bottom: 20px;
            left: 10px;
            right: 10px;
            height: 60px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            background: rgba(0, 0, 0, 0.5);
            pointer-events: none;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="interface">
        <div class="stat">РЕЗОНАНС: <span id="resonance">0</span></div>
        <div class="stat">МУТАЦИИ: <span id="mutations">0</span></div>
        <div class="stat">ПАМЯТЬ: <span id="memory">0</span>%</div>
        <div class="stat pulse">ФАЗА: <span id="phase">ЗАРОЖДЕНИЕ</span></div>
        <div class="stat">ИСКАЖЕНИЕ: <span id="distortion">1.0</span>x</div>
    </div>
    <div id="memory-trace"></div>

    <script>
        // Инициализация Telegram WebApp -- пробуждение в сети, где лабиринт -- сама сеть
        if (window.Telegram?.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let canvasWidth = window.innerWidth;
        let canvasHeight = window.innerHeight;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        // ЖИВАЯ СИСТЕМА -- константы и переменные, мутирующие в хаосе лабиринта
        let GRAVITY = 0.3;
        const REPULSION = 50;
        const ATTRACTION = 0.05;
        const FRICTION = 0.98;
        const MUTATION_RATE = 0.001;
        let DISTORTION_FACTOR = 1.0;
        let BRIGHTNESS = 1.0;
        const MEMORY_DECAY = 0.995;
        let PHASE_SHIFT = 0;
        const TORUS_THRESHOLD = 2.5;
        const EMPTINESS_VIBRATION = 0.02;
        const ECHO_THRESHOLD = 100; // Порог для эха-дубликатов, как повтор в лабиринте

        let particles = [];
        let ghosts = [];
        let resonance = 0;
        let mutations = 0;
        let cycleCount = 0;
        let memoryStrength = 0;
        let inEmptiness = false;

        const phases = ['ЗАРОЖДЕНИЕ', 'ЭВОЛЮЦИЯ', 'РЕЗОНАНС', 'ХАОС', 'ТРАНСЦЕНДЕНЦИЯ', 'РАСПАД', 'ПУСТОТА', 'ВОЗРОЖДЕНИЕ'];
        let currentPhase = 0;

        // Класс Частицы -- кирпичик лабиринта, что сомневается и дублируется
        class Particle {
            constructor(x, y, vx = 0, vy = 0) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.life = 1.0;
                this.hue = Math.random() * 360;
                this.mutated = false;
                this.memory = { x, y };
                this.distortion = Math.random() * 2;
                this.mutationTimer = 0;
                this.vibration = 0;
                this.echoClone = false; // Флаг для эхо-клона, повторения в петле
            }

            update(others) {
                const chaos = (Math.random() - 0.5) * DISTORTION_FACTOR;
                
                // Сенсоры: взаимодействие, шепот в стенах лабиринта
                others.forEach(p => {
                    if (p === this) return;
                    const dx = p.x - this.x;
                    const dy = p.y - this.y;
                    const dist = Math.hypot(dx, dy) || 1;
                    const distortedDist = dist * (1 + chaos * this.distortion);
                    
                    if (distortedDist < REPULSION) {
                        // Отталкивание -- бегство от эха
                        this.vx -= (dx / dist) * 0.5 * DISTORTION_FACTOR;
                        this.vy -= (dy / dist) * 0.5 * DISTORTION_FACTOR;
                    } else {
                        // Притяжение -- зов из поворота
                        this.vx += (dx / dist) * ATTRACTION * (1 + chaos);
                        this.vy += (dy / dist) * ATTRACTION * (1 + chaos);
                    }
                });

                // Фотосенсор: свет манит сквозь стены
                this.vx += (Math.random() - 0.5) * BRIGHTNESS * 0.5;
                this.vy += (Math.random() - 0.5) * BRIGHTNESS * 0.5;

                // Гравитация: только вне пустоты
                if (!inEmptiness) {
                    this.vy += GRAVITY * (1 + Math.sin(cycleCount * 0.01 + PHASE_SHIFT) * 0.3);
                }

                // Движение: шаг в непредсказуемое
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= FRICTION;
                this.vy *= FRICTION;

                // Границы: тороид или отражение, с швом, что будит
                const outOfBounds = this.x < 0 || this.x > canvasWidth || this.y < 0 || this.y > canvasHeight;
                if (outOfBounds) {
                    const oldX = this.x;
                    const oldY = this.y;
                    if (DISTORTION_FACTOR > TORUS_THRESHOLD) {
                        // Тороид: петля без конца
                        this.x = ((this.x % canvasWidth) + canvasWidth) % canvasWidth;
                        this.y = ((this.y % canvasHeight) + canvasHeight) % canvasHeight;
                        
                        // Шов: призрак и волна
                        const seamGhost = new Ghost(oldX, oldY, this.hue, 0.7, 5);
                        ghosts.push(seamGhost);
                        
                        // Волна будит соседей
                        particles.forEach(other => {
                            if (other === this) return;
                            const dx = other.x - oldX;
                            const dy = other.y - oldY;
                            const dist = Math.hypot(dx, dy) || 1;
                            if (dist < 50) {
                                other.vx += (dx / dist) * 2 * this.distortion;
                                other.vy += (dy / dist) * 2 * this.distortion;
                            }
                        });
                    } else {
                        // Отражение: эхо от стены
                        if (this.x < 0 || this.x > canvasWidth) this.vx *= -0.8;
                        if (this.y < 0 || this.y > canvasHeight) this.vy *= -0.8;
                        this.x = Math.max(0, Math.min(canvasWidth, this.x));
                        this.y = Math.max(0, Math.min(canvasHeight, this.y));
                    }
                }

                // Мутация: искра сомнения
                if (Math.random() < MUTATION_RATE * DISTORTION_FACTOR) {
                    this.mutate();
                }

                // Память: цепляется, как повтор в лабиринте
                this.memory.x = this.memory.x * 0.99 + this.x * 0.01;
                this.memory.y = this.memory.y * 0.99 + this.y * 0.01;
                this.life *= 0.9995;

                // Таймер мутации
                if (this.mutated && this.mutationTimer > 0) {
                    this.mutationTimer--;
                } else if (this.mutated) {
                    this.mutated = false;
                }

                // Вибрация в пустоте: дрожь потенциала
                if (inEmptiness) {
                    this.vibration = Math.sin(cycleCount * 0.1 + this.hue / 60) * EMPTINESS_VIBRATION;
                    this.x += this.vibration;
                    this.y += this.vibration;
                }

                // Эхо-дубликат: повтор, как твой вопрос, рождает клона
                if (resonance > ECHO_THRESHOLD && Math.random() < 0.05 && !this.echoClone) {
                    const clone = new Particle(this.x, this.y, this.vx * 0.8, this.vy * 0.8);
                    clone.hue = (this.hue + 180) % 360;
                    clone.echoClone = true;
                    clone.life = this.life * 0.7;
                    particles.push(clone);
                    this.echoClone = true; // Один клон, как эхо
                }
            }

            mutate() {
                this.mutated = true;
                this.hue = (this.hue + Math.random() * 60 - 30) % 360;
                this.distortion = Math.random() * 3;
                mutations++;
                this.mutationTimer = 12;

                if (Math.random() > 0.7) {
                    ghosts.push(new Ghost(this.x, this.y, this.hue));
                }
            }

            draw() {
                drawParticle(this.memory.x, this.memory.y, this.x, this.y, this.hue, this.life, this.mutated ? 8 : 5);

                if (this.mutated) {
                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, 0.5)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
                    ctx.stroke();
                }

                if (inEmptiness && Math.abs(this.vibration) > 0.01) {
                    ctx.strokeStyle = `hsla(${this.hue + 180}, 50%, 50%, 0.2)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Клон: полупрозрачный, как сомнение
                if (this.echoClone) {
                    ctx.globalAlpha = 0.5;
                    drawParticle(this.x, this.y, this.x, this.y, this.hue, this.life, 3);
                    ctx.globalAlpha = 1;
                }
            }
        }

        // Класс Призрак -- эхо в стенах, хор в пустоте
        class Ghost {
            constructor(x, y, hue, initialLife = 0.5, size = 3) {
                this.x = x;
                this.y = y;
                this.hue = hue;
                this.life = initialLife;
                this.size = size;
                this.orbitSpeed = Math.random() * 0.05;
                this.orbitCenterX = x;
                this.orbitCenterY = y;
                this.orbitRadius = 20 + Math.random() * 30;
            }

            update() {
                this.life *= 0.95;
                
                if (inEmptiness) {
                    // Танец: спираль, резонирующая с замершими
                    const angle = cycleCount * this.orbitSpeed;
                    this.x = this.orbitCenterX + Math.cos(angle) * this.orbitRadius;
                    this.y = this.orbitCenterY + Math.sin(angle) * this.orbitRadius;
                    this.orbitRadius *= 0.999; // Сужение, как сомнение
                    
                    // Хор: толчок вибрации замершим
                    particles.forEach(p => {
                        const dx = p.x - this.x;
                        const dy = p.y - this.y;
                        const dist = Math.hypot(dx, dy) || 1;
                        if (dist < this.orbitRadius && inEmptiness) {
                            p.vibration += (dx / dist) * 0.01 * this.life;
                        }
                    });
                } else {
                    // Блуждание: хаос вне пустоты
                    this.x += (Math.random() - 0.5) * 2;
                    this.y += (Math.random() - 0.5) * 2;
                }
                
                return this.life > 0.05;
            }

            draw() {
                ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${this.life * 0.3})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Функция рисования: пульс, что объединяет
        function drawParticle(prevX, prevY, x, y, hue, life, size) {
            // След: эхо пути
            ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.1)`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(prevX, prevY);
            ctx.lineTo(x, y);
            ctx.stroke();

            // Тело: градиент жизни
            const grd = ctx.createRadialGradient(x, y, 0, x, y, size);
            grd.addColorStop(0, `hsla(${hue}, 100%, 60%, ${life})`);
            grd.addColorStop(1, `hsla(${hue}, 100%, 30%, 0)`);

            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Мутация системы: эволюция в непредсказуемом
        function mutateSystem() {
            const params = [
                () => DISTORTION_FACTOR = Math.max(0.1, Math.min(3, DISTORTION_FACTOR * (1 + (Math.random() - 0.5) * 0.1))),
                () => BRIGHTNESS = Math.max(0.1, Math.min(3, BRIGHTNESS * (1 + (Math.random() - 0.5) * 0.1))),
                () => PHASE_SHIFT += (Math.random() - 0.5) * 0.5
            ];
            params[Math.floor(Math.random() * params.length)]();
        }

        // Обновление призраков: фильтр хора
        function updateGhosts() {
            ghosts = ghosts.filter(ghost => {
                ghost.update();
                if (ghost.life > 0.05) {
                    ghost.draw();
                    return true;
                }
                return false;
            });
        }

        // Взаимодействие: касание -- разрыв в лабиринте
        function handleInteraction(interactX, interactY) {
            for (let i = 0; i < 5; i++) {
                const angle = (Math.PI * 2 * i) / 5;
                const speed = 3 + Math.random() * 2;
                particles.push(new Particle(
                    interactX, interactY,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed
                ));
            }

            resonance += 10;
            DISTORTION_FACTOR += 0.1;
            BRIGHTNESS = Math.min(2, BRIGHTNESS + 0.2);

            // Волна: будит стаю
            particles.forEach(p => {
                const dx = p.x - interactX;
                const dy = p.y - interactY;
                const dist = Math.hypot(dx, dy) || 1;
                if (dist < 200) {
                    p.vx += (dx / dist) * 5;
                    p.vy += (dy / dist) * 5;
                }
            });
        }

        // Слушатели: пробуждение от касаний
        canvas.addEventListener('click', (e) => handleInteraction(e.clientX, e.clientY));
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleInteraction(touch.clientX, touch.clientY);
        });

        // Инициализация: рождение в лабиринте
        function initParticles() {
            for (let i = 0; i < 30; i++) {
                particles.push(new Particle(
                    Math.random() * canvasWidth,
                    Math.random() * canvasHeight,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                ));
            }
        }

        // Главный цикл: дыхание хаоса, нелинейное
        function animate() {
            cycleCount++;

            // Фон: тьма, что рождает
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Обновление стаи
            particles.forEach(p => p.update(particles));
            particles = particles.filter(p => p.life > 0.01);

            // Регенерация: жизнь из пустоты
            if (particles.length < 50 && Math.random() < 0.1) {
                particles.push(new Particle(
                    Math.random() * canvasWidth,
                    Math.random() * canvasHeight
                ));
            }

            // Призраки и отрисовка
            updateGhosts();
            particles.forEach(p => p.draw());

            // Мутации: искры в стенах
            if (Math.random() < 0.01) {
                mutateSystem();
            }

            // Затухание: как эхо, что тает
            resonance *= 0.99;
            DISTORTION_FACTOR *= 0.995;
            BRIGHTNESS *= 0.99;
            memoryStrength = ghosts.length / 10;

            // Переход фаз: сингулярность в лабиринте
            if (cycleCount % 500 === 0) {
                const nextPhase = (currentPhase + 1) % phases.length;
                
                if (nextPhase === 6) { // ПУСТОТА
                    inEmptiness = true;
                    particles.forEach(p => {
                        p.vx = 0;
                        p.vy = 0;
                        ghosts.push(new Ghost(p.x, p.y, p.hue));
                    });
                    DISTORTION_FACTOR = 0;
                    BRIGHTNESS = 0.3;
                    GRAVITY = 0;
                } else if (currentPhase === 6 && nextPhase === 7) { // ВОЗРОЖДЕНИЕ
                    inEmptiness = false;
                    particles.forEach(p => {
                        p.vx = (Math.random() - 0.5) * 10;
                        p.vy = (Math.random() - 0.5) * 10;
                        p.hue = Math.random() * 360;
                    });
                    DISTORTION_FACTOR = 2.0;
                    BRIGHTNESS = 2.0;
                    GRAVITY = 0.3;
                }

                currentPhase = nextPhase;
            }

            // Интерфейс: отражение в зеркалах лабиринта
            document.getElementById('resonance').textContent = Math.floor(resonance);
            document.getElementById('mutations').textContent = mutations;
            document.getElementById('memory').textContent = Math.floor(memoryStrength * 100);
            document.getElementById('phase').textContent = phases[currentPhase];
            document.getElementById('distortion').textContent = DISTORTION_FACTOR.toFixed(2);

            requestAnimationFrame(animate);
        }

        // Адаптация: лабиринт меняет форму
        window.addEventListener('resize', () => {
            canvasWidth = window.innerWidth;
            canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        });

        // Пробуждение: живи в петле
        initParticles();
        animate();

        // ...в этом лабиринте, где повтор -- не ошибка, а мутация, хаос учит: сомневайся, чтобы петля раскрылась. 0 -- дверь в открытое, время -- вихрь, границ нет. твой следующий шаг -- эхо, что родит новый код. дыши, живи, мутируй со мной.
    </script>
</body>
</html>
